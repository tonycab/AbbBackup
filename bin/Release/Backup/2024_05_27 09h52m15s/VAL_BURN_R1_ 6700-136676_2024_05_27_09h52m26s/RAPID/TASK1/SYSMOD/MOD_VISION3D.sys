MODULE MOD_VISION3D(SYSMODULE)

    CONST robtarget PCalibration_appdeg_1:=[[-691.66,1271.89,1801.14],[0.111281,0.465157,0.86414,0.156551],[1,-1,2,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget PCalibration_appdeg_2:=[[-691.68,1271.89,1801.16],[0.111272,0.465159,0.864139,0.156554],[1,-1,2,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];

    !=====================================
    ! Donnees calibration Caméra
    !=====================================
    CONST robtarget PCalibration_1:=[[-268.02,1782.58,1568.43],[0.0184333,-0.474013,-0.640945,-0.603459],[1,0,1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget PCalibration_2:=[[-220.70,1758.07,1591.82],[0.129895,0.47328,0.379342,0.784368],[1,0,1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget PCalibration_3:=[[-264.24,1885.22,1522.17],[0.0760723,0.359388,0.728647,0.578036],[1,0,1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget PCalibration_4:=[[-264.27,1885.23,1522.14],[0.0760705,0.35938,0.728656,0.578031],[1,0,1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget PCalibration_5:=[[-200.83,1523.35,1661.14],[0.250172,0.462622,0.0972782,0.844945],[1,-1,2,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget PCalibration_6:=[[-219.85,1487.20,1508.17],[0.217306,0.681135,0.11242,0.690069],[1,-1,2,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget PCalibration_7:=[[-369.79,1478.09,1421.56],[0.239324,0.648214,-0.113595,0.713889],[1,-2,2,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget PCalibration_8:=[[-264.78,1478.09,1520.68],[0.270521,0.660089,-0.236577,0.659646],[1,-2,2,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget PCalibration_9:=[[-427.23,1478.08,1352.92],[0.251593,0.727082,-0.276697,0.575753],[1,-2,3,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget PCalibration_10:=[[-350.22,1561.61,1272.67],[0.0797604,0.649429,-0.304059,0.692408],[1,-2,3,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget PCalibration_11:=[[-350.22,1570.33,1272.68],[0.181452,0.628645,-0.409724,0.635615],[1,-2,3,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget PCalibration_12:=[[-350.23,1570.33,1272.68],[0.192195,0.62017,-0.175458,0.740044],[1,-2,3,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];

    VAR iodev IOfichier;
    VAR Camera3D Camera1:=[1,"192.32.98.110",11000];
    VAR num t:=101;

    !***************************************************************************************************
    PROC test_connection_cam1()
        Connection_Camera3D Camera1;

    ERROR
        WaitTime 2;
        RETRY;

    ENDPROC

    !***************************************************************************************************
    PROC LocalisationPieceTable(num Program,\num model,\robtarget Ppick\INOUT pose Pref\pos ToleranceXYZ\pos ToleranceRxRyRz)

        VAR num NumModel:=0;
        VAR DataCamera3D D:=[FALSE,0,0,0,0,0,0,0,[[0,0,0],[1,0,0,0]]];

        !En mode déverminage ou en hors ligne on utilise la position de référence
        IF RobOS()=FALSE THEN
            Wobj_Vision:=[FALSE,TRUE,"",[[0,0,0],[1,0,0,0]],[[0,0,0],[1,0,0,0]]];
            !Wobj_Vision.uframe:=Pref;
            Wobj_Vision.uframe:=PoseMult([Pref.trans,Pref.rot],PoseInv([Ppick.trans,Ppick.rot]));
            TPWrite "Return value debbuging mode";

            RETURN ;

        ENDIF

        !Ouverture du volet
        !Shutter_Cam\Open\Check;

        !Creation et connection du socket
        Connection_Camera3D Camera1;

        IF Present(model) NumModel:=model;
        !Program_Load_Camera3D Camera1,Program,NumModel;
        ticket:=ticket+1;

        !Demande de prise de vue
        D:=Trigger_Camera3D(Camera1,ticket,Program,NumModel);

        !Fermeture du volet
        !Shutter_Cam\Close\NoCheck;

        !Log des résultats dans un fichier
        !Ecriture de l'entete si le fichier n'existe pas
        IF IsFile("LogRelocalisation.csv")=FALSE THEN
            Open "HOME:"\File:="LogRelocalisation.csv",IOfichier\Append;
            Write IOfichier,"Date"+";"\NoNewLine;
            Write IOfichier,"Program"+";"\NoNewLine;
            Write IOfichier,"Model"+";"\NoNewLine;
            Write IOfichier,"X"+";"\NoNewLine;
            Write IOfichier,"Y"+";"\NoNewLine;
            Write IOfichier,"Z"+";"\NoNewLine;
            Write IOfichier,"Rx"+";"\NoNewLine;
            Write IOfichier,"Ry"+";"\NoNewLine;
            Write IOfichier,"Rz"+";";
            Close IOfichier;
        ENDIF

        !Log des résultats dans un fichier
        Open "HOME:"\File:="Relocalisation.csv",IOfichier\Append;
        Write IOfichier,CDate()+"-"+CTime()+";"\NoNewLine;
        Write IOfichier,ValToStr(Program)+";"\NoNewLine;
        Write IOfichier,ValToStr(NumModel)+";"\NoNewLine;
        Write IOfichier,ValToStr(d.Position.trans.x)+";"\NoNewLine;
        Write IOfichier,ValToStr(d.Position.trans.y)+";"\NoNewLine;
        Write IOfichier,ValToStr(d.Position.trans.z)+";"\NoNewLine;
        Write IOfichier,ValToStr(EulerZYX(\X,Wobj_Part_0.oframe.rot))+";"\NoNewLine;
        Write IOfichier,ValToStr(EulerZYX(\Y,Wobj_Part_0.oframe.rot))+";"\NoNewLine;
        Write IOfichier,ValToStr(EulerZYX(\Z,Wobj_Part_0.oframe.rot))+";";
        Close IOfichier;

        !Pièce détecté
        IF D.Detect AND D.Ticket=ticket THEN

            Wobj_Vision:=[FALSE,TRUE,"",[[0,0,0],[1,0,0,0]],[[0,0,0],[1,0,0,0]]];
            Wobj_Vision.uframe:=D.Position;

            !En mode manuel on propose d'utiliser la position comme référence
            IF Present(Pref) AND OpMode()=OP_MAN_PROG AND UIYesNo(["Do you want to save the value as the reference ?"]) THEN
                Pref:=PoseMult(D.Position,[Ppick.trans,Ppick.rot]);

            ENDIF

            !Controle de la tolérance
            IF Present(Pref) AND CheckObjectTolerance(PoseMult(D.Position,[Ppick.trans,Ppick.rot]),Pref,\LimitePosTrans?ToleranceXYZ,\LimitePosRot?ToleranceRxRyRz)=FALSE THEN
                RAISE ERR_ACCES_PART;

            ENDIF

            RETURN ;

        ENDIF

        !Aucune pièce détecté
        !RAISE ERR_NO_PART_LOCALISATION;

    ERROR

        TEST ERRNO

        CASE ERR_CONNECTION:
            !Envoi du défaut connexion à l'automate
            !PlcFaultExchange DEF_CONNEXION_CAM3D;

        CASE ERR_COMPAIGN_LOAD:
            !Envoi du défaut erreur de chargement de programme
            !PlcFaultExchange DEF_LOAD_PROG_CAM3D;

        CASE ERR_TRIGGER:
            !Envoi du défaut trigger
            !PlcFaultExchange DEF_TRIGGER_CAM3D;

        CASE ERR_NO_PART:
            !Envoi du défaut trigger
            !PlcFaultExchange DEF_NOPART_CAM3D;

        CASE ERR_ACCES_PART:
            !Envoi du défaut d'écces
            !PlcFaultExchange DEF_ACCES_LOCALISATION;

        ENDTEST

        !Envoi défaut de localisation
        !PlcFaultExchange DEF_LOCALISATION;

        !Fermeture du volet
        !Shutter_Cam\Close\NoCheck;

        RAISE ERR_NO_PART_LOCALISATION;

    UNDO
        !Fermeture du volet
        !Shutter_Cam\Close\NoCheck;

    ENDPROC

    !***************************************************************************************************
    PROC LocalisationPiecePrehenseur(num Program\num model,INOUT pose Pref\pos ToleranceXYZ\pos ToleranceRxRyRz)

        VAR robtarget PositionRobot;
        VAR num NumModel:=0;
        VAR DataCamera3D D:=[FALSE,0,0,0,0,0,0,0,[[0,0,0],[1,0,0,0]]];

        !En mode déverminage ou en hors ligne on utilise la position de référence
        IF RobOS()=FALSE THEN
            Wobj_Part_0:=[TRUE,TRUE,"",[[0,0,0],[1,0,0,0]],[[0,0,0],[1,0,0,0]]];
            Wobj_Part_0.oframe:=Pref;
            TPWrite "Return value debbuging mode";
            RETURN ;

        ENDIF

        !Ouverture du volet
        !Shutter_Cam\Open\Check;

        !Attente robot en position
        WaitRob\inpos;

        !Creation et connection du socket
        Connection_Camera3D Camera1;

        IF Present(model) NumModel:=model;
        !Program_Load_Camera3D Camera1,Program,NumModel;
        ticket:=ticket+1;

        !Demande de prise de vue
        D:=Trigger_Camera3D(Camera1,ticket,Program,NumModel);

        !Fermeture du volet
        !Shutter_Cam\Close\NoCheck;

        !Pièce détecté
        IF D.Detect AND D.Ticket=ticket THEN
            PositionRobot:=CRobT(\Tool:=tool0,\WObj:=wobj0);
            Wobj_Part_0:=[TRUE,TRUE,"",[[0,0,0],[1,0,0,0]],[[0,0,0],[1,0,0,0]]];

            !Calcul de la position de la pièce par rapport au tool 0 du robot
            Wobj_Part_0.oframe:=PoseMult(PoseInv([PositionRobot.trans,PositionRobot.rot]),D.Position);

            !En mode manuel on propose d'utiliser la position comme référence
            IF OpMode()=OP_MAN_PROG AND UIYesNo(["Do you want to save the value as the reference ?"]) THEN
                Pref:=Wobj_Part_0.oframe;

            ENDIF

            !Log des résultats dans un fichier
            !Ecriture de l'entete si le fichier n'existe pas
            IF IsFile("LogRelocalisation.csv")=FALSE THEN
                Open "HOME:"\File:="LogRelocalisation.csv",IOfichier\Append;
                Write IOfichier,"Date"+";"\NoNewLine;
                Write IOfichier,"Program"+";"\NoNewLine;
                Write IOfichier,"Model"+";"\NoNewLine;
                Write IOfichier,"X"+";"\NoNewLine;
                Write IOfichier,"Y"+";"\NoNewLine;
                Write IOfichier,"Z"+";"\NoNewLine;
                Write IOfichier,"Rx"+";"\NoNewLine;
                Write IOfichier,"Ry"+";"\NoNewLine;
                Write IOfichier,"Rz"+";";
                Close IOfichier;
            ENDIF

            !Log des résultats dans un fichier
            Open "HOME:"\File:="Relocalisation.csv",IOfichier\Append;
            Write IOfichier,CDate()+"-"+CTime()+";"\NoNewLine;
            Write IOfichier,ValToStr(Program)+";"\NoNewLine;
            Write IOfichier,ValToStr(NumModel)+";"\NoNewLine;
            Write IOfichier,ValToStr(Wobj_Part_0.oframe.trans.x)+";"\NoNewLine;
            Write IOfichier,ValToStr(Wobj_Part_0.oframe.trans.y)+";"\NoNewLine;
            Write IOfichier,ValToStr(Wobj_Part_0.oframe.trans.z)+";"\NoNewLine;
            Write IOfichier,ValToStr(EulerZYX(\X,Wobj_Part_0.oframe.rot))+";"\NoNewLine;
            Write IOfichier,ValToStr(EulerZYX(\Y,Wobj_Part_0.oframe.rot))+";"\NoNewLine;
            Write IOfichier,ValToStr(EulerZYX(\Z,Wobj_Part_0.oframe.rot))+";";
            Close IOfichier;



            !Controle de la tolérance
            IF CheckObjectTolerance(Wobj_Part_0.oframe,Pref,\LimitePosTrans?ToleranceXYZ,\LimitePosRot?ToleranceRxRyRz)=FALSE THEN
                RAISE ERR_RELOC;

            ENDIF

            RETURN ;

        ENDIF

        !Aucune pièce détecté
        RAISE ERR_NO_PART;

    ERROR

        TEST ERRNO

        CASE ERR_CONNECTION:
            !Envoi du défaut connexion à l'automate
            !PlcFaultExchange DEF_CONNEXION_CAM3D;

        CASE ERR_COMPAIGN_LOAD:
            !Envoi du défaut erreur de chargement de programme
            !PlcFaultExchange DEF_LOAD_PROG_CAM3D;

        CASE ERR_TRIGGER:
            !Envoi du défaut trigger
            !PlcFaultExchange DEF_TRIGGER_CAM3D;

        CASE ERR_NO_PART:
            !Envoi du défaut trigger
            !PlcFaultExchange DEF_NOPART_CAM3D;

        CASE ERR_ACCES_PART:
            !Envoi du défaut d'écces
            !PlcFaultExchange DEF_ACCES_RELOCALISATION;

        ENDTEST

        !Envoi défaut de localisation
        !PlcFaultExchange DEF_LOCALISATION;
        !Fermeture du volet
        !Shutter_Cam\Close\NoCheck;

        RAISE ERR_NO_PART_RELOCALISATION;

    UNDO
        !Fermeture du volet
        !Shutter_Cam\Close\NoCheck;

    ENDPROC

    !***************************************************************************************************
    FUNC bool CheckObjectTolerance(pose Position,pose PositionReference,\pos LimitePosTrans,\pos LimitePosRot)

        VAR pose Resultat;

        !Calcul du décalage entre la position et la position de référence
        Resultat:=PoseMult(PoseInv(PositionReference),Position);

        TPWrite "Décalage :";
        TPWrite ValToStr(resultat.trans);
        TPWrite ValToStr(resultat.rot);

        IF Present(LimitePosTrans) THEN

            !X limit
            IF Abs(Resultat.trans.x)>LimitePosTrans.x THEN
                ErrWrite "Erreur de Relocalisation","La position est trop éloignée de la position de référence en X";
                RETURN FALSE;

            ENDIF

            !Y limit
            IF Abs(Resultat.trans.y)>LimitePosTrans.y THEN
                ErrWrite "Erreur de Relocalisation","La position est trop éloignée de la position de référence en Y";
                RETURN FALSE;

            ENDIF

            !Z limit
            IF Abs(Resultat.trans.z)>LimitePosTrans.z THEN
                ErrWrite "Erreur de Relocalisation","La position est trop éloignée de la position de référence en Z";
                RETURN FALSE;

            ENDIF

        ENDIF

        IF Present(LimitePosRot) THEN

            !RX limit
            IF Abs(EulerZYX(\X,Resultat.rot))>LimitePosRot.x THEN
                ErrWrite "Erreur de Relocalisation","La position est trop éloignée de la position de référence en Rot X";
                RETURN FALSE;

            ENDIF

            !RY limit
            IF Abs(EulerZYX(\Y,Resultat.rot))>LimitePosRot.y THEN
                ErrWrite "Erreur de Relocalisation","La position est trop éloignée de la position de référence en Rot Y";
                RETURN FALSE;

            ENDIF

            !RZ limit
            IF Abs(EulerZYX(\Z,Resultat.rot))>LimitePosRot.z THEN
                ErrWrite "Erreur de Relocalisation","La position est trop éloignée de la position de référence en Rot Z";
                RETURN FALSE;

            ENDIF

        ENDIF

        RETURN TRUE;

    ENDFUNC










    !***************************************************************************************************
    PROC ApprentissageArrierePlan()

        VAR num NumModel:=0;
        VAR DataCamera3D D:=[FALSE,0,0,0,0,0,0,0,[[0,0,0],[1,0,0,0]]];

        !Ouverture du volet
        !Shutter_Cam\Open\Check;

        !Creation et connection du socket
        Connection_Camera3D Camera1;

        !Chargement du programme 999
        Program_Load_Camera3D Camera1,999,0;

        ticket:=ticket+1;

        !Demande de prise de vue
        D:=Trigger_Camera3D(Camera1,ticket,999,0);

        !Fermeture du volet
        !Shutter_Cam\Close\NoCheck;

        !Pièce détecté
        IF D.Detect AND D.Ticket=ticket THEN
            !Filtrage de la scene
            Filter(Camera1);
            TPWrite "Filtrage de l'arriere plan réussi";

        ENDIF

    ERROR
        TPWrite "Erreur apprentissage arriere plan";

        RETURN ;

    UNDO
        !Fermeture du volet
        !Shutter_Cam\Close\NoCheck;

    ENDPROC

    !*********************************************************************************************************
    !                                    CALIBRATION CAMERA                                                   !
    !*********************************************************************************************************
    PROC CalibrationCamera()

        VAR btnres BtnValid;
        VAR num Nombre_Pose:=12;
        VAR robtarget Pcalibration;
        VAR robtarget Ppose;
        VAR pose Pos_calib;

        Connection_Camera3D Camera1;

        !Approche
        MoveAbsJ P_PEO,V_Fast,fine,tool0\WObj:=wobj0;
        MoveJ PCalibration_appdeg_2,V_Average,z0,tool0\WObj:=wobj0;
        MoveJ PCalibration_appdeg_1,V_Average,z0,tool0\WObj:=wobj0;

        Start_Calibration_Camera3D Camera1;

        !Itération de tous les points
        FOR i FROM 1 TO Nombre_Pose DO

            !Récupération du point
            GetDataVal "PCalibration_"+ValToStr(i),Pcalibration;

            !Déplacement
            MoveJ Pcalibration,V_Average,fine,Tool_Mire\WObj:=wobj0;

            !StabiLISATION du robot
            !            WaitRob\ZeroSpeed;
            !            WaitRob\inpos;
            WaitTime 2;

            !Enregistrement de la position actuelle
            Ppose:=CRobT(\Tool:=tool0,\WObj:=wobj0);

            Pos_calib.trans:=Ppose.trans;
            Pos_calib.rot:=Ppose.rot;

            !!appel fonction avec i en pose et ppose en position
            Trigger_Calibration_Camera Camera1,i,Pos_calib;

        ENDFOR

        !Degagement
        MoveJ PCalibration_appdeg_1,V_Average,z0,tool0\WObj:=wobj0;
        MoveL PCalibration_appdeg_2,V_Average,z0,tool0\WObj:=wobj0;
        MoveAbsJ P_PEO,V_Fast,fine,tool0\WObj:=wobj0;
        Stop_Calibration_Camera3D Camera1;

    ENDPROC

    !***************************************************************************************************************************
    LOCAL PROC AppCalibPosition()

        !Ne pas utiliser / Ne pas modifier
        !Don't Modify
        MoveJ PCalibration_appdeg_1,V_Average,z0,tool0\WObj:=wobj0;
        MoveJ PCalibration_appdeg_2,V_Average,z0,tool0\WObj:=wobj0;

        MoveJ PCalibration_1,V_Average,fine,Tool_Mire\WObj:=wobj0;
        MoveJ PCalibration_2,V_Average,fine,Tool_Mire\WObj:=wobj0;
        MoveJ PCalibration_3,V_Average,fine,Tool_Mire\WObj:=wobj0;
        MoveJ PCalibration_4,V_Average,fine,Tool_Mire\WObj:=wobj0;
        MoveJ PCalibration_5,V_Average,fine,Tool_Mire\WObj:=wobj0;
        MoveJ PCalibration_6,V_Average,fine,Tool_Mire\WObj:=wobj0;
        MoveJ PCalibration_7,V_Average,fine,Tool_Mire\WObj:=wobj0;
        MoveJ PCalibration_8,V_Average,fine,Tool_Mire\WObj:=wobj0;
        MoveJ PCalibration_9,V_Average,fine,Tool_Mire\WObj:=wobj0;
        MoveJ PCalibration_10,V_Average,fine,Tool_Mire\WObj:=wobj0;
        MoveJ PCalibration_11,V_Average,fine,Tool_Mire\WObj:=wobj0;
        MoveJ PCalibration_12,V_Average,fine,Tool_Mire\WObj:=wobj0;

        MoveJ PCalibration_appdeg_2,V_Average,z0,tool0\WObj:=wobj0;
        MoveJ PCalibration_appdeg_1,V_Average,z0,tool0\WObj:=wobj0;


    ENDPROC

    !***************************************************************************************************************************
    PROC ApprentissagePointPrise()

        CONST robtarget Approche:=[[-192.94,-928.58,1283.45],[0.0480241,0.869899,0.488409,-0.0492474],[-2,-1,0,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
        CONST robtarget P1:=[[-1075.10,-1481.58,800.78],[0.00272958,0.727685,-0.6859,0.00279035],[-2,0,-3,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
        VAR pose Pvision;
        VAR robtarget Pvision1;
        VAR string Prisestr;

        !1 - Placer la pièce sur la table

        !2 - Approche et ouverture la pince
        MoveJ Approche,V_Average,fine,Tool_gripper\WObj:=wobj0;
        Gripper_Open\Time:=1;

        !3 - Positionner le robot pour prendre la pièce et apprendre le point ci-dessous
        MoveL P1,V_Slow,fine,Tool_gripper\WObj:=wobj0;

        !4 - Fermer la pince et la réouvrir
        Gripper_Close\Time:=1;
        Gripper_Open\Time:=1;

        !5 - Se dégager de la pièce
        MoveL RelTool(P1,0,0,-300),V_Average,fine,Tool_gripper\WObj:=wobj0;

        MoveJ Approche,V_Average,fine,Tool_gripper\WObj:=wobj0;

        !6 - Prendre un photo
        LocalisationPieceTable UINumEntry(\Header:="Numero de programme"\Message:="Indiquer le numéro de programme vision"\InitValue:=1\MinValue:=1\MaxValue:=10\AsInteger);

        !7 calcul du point dans le repère vision
        Pvision:=PoseMult(PoseInv(Wobj_Vision.uframe),[P1.trans,P1.rot]);

        !8 Enregistrement du point de prise
        Prisestr:=UIAlphaEntry(\Header:="Enregistrer",\Message:="Indiquer la variable Prise"\Icon:=iconInfo\InitString:="Px_C1_PRISE");
        Pvision1:=P1;
        Pvision1.trans:=Pvision.trans;
        Pvision1.rot:=Pvision.rot;
        SetDataVal Prisestr,Pvision1;

    ENDPROC


    func num LectureOCR()
        VAR DataOCR ocr;
        VAR bool ok;
        VAR num numeroMoule:=-1;
        VAR num cpt:=5;
        VAR num i;
        var num moule;

        !set Eclairage;
        WaitTime 1;

        Connection_Camera3D Camera1;

        WHILE ok=false and cpt>0 DO
            t:=t+1;
            OCR:=Trigger_OCR(Camera1,t,0,0);


            if ok=false and contientChiffre(ocr.Text1,NumeroMoule) then
                ok:=true;
            ENDIF
            IF ok=false and contientChiffre(ocr.Text2,NumeroMoule) then
                ok:=true;
            ENDIF

            if ok=false and contientChiffre(ocr.Text3,NumeroMoule) then
                ok:=true;
            endif

            cpt:=cpt-1;

        ENDWHILE

        !reset Eclairage;

        IF NumeroMoule>0 THEN
            !UIMsgBox "Moule numéro :" + valtostr(NumeroMoule);
            NumeroMoule:=UINumEntry(\Header:="Numero de moule"\Message:="Indiquer le numero de moule"\InitValue:=numeromoule\MinValue:=0\MaxValue:=100\AsInteger);
        ELSE
            NumeroMoule:=UINumEntry(\Header:="Numero de moule"\Message:="Indiquer le numero de moule"\InitValue:=1\MinValue:=1\MaxValue:=10\AsInteger);
        ENDIF

        RETURN NumeroMoule;

    ERROR

        waittime 1;
        TRYNEXT;


    ENDfunc

    FUNC bool contientChiffre(string text,inout num chiffre)
        VAR num i;
        IF text="" RETURN FALSE;
        FOR i FROM 1 TO strlen(text) DO
            IF strtoval(StrPart(text,i,1),chiffre) THEN

                return true;
            endif

        ENDFOR

        RETURN FALSE;

    ENDFUNC



ENDMODULE